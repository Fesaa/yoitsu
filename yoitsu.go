package yoitsu

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"path/filepath"
	"slices"
)

type Metadata struct {
	packageName string

	SmartMapMapping bool
}

type Accessors struct {
	Generate         bool
	ById             bool
	GroupByPrimitive bool
}

type Yoitsu struct {
	src      Source
	metadata Metadata
	universe Universe

	accessors Accessors

	root   interface{}
	parser *Parser
	file   *ast.File
}

func WithUniverse(universe Universe) Option[*Yoitsu] {
	return func(y *Yoitsu) {
		y.universe = universe
	}
}

func WithPackageName(name string) Option[*Yoitsu] {
	return func(y *Yoitsu) {
		y.metadata.packageName = name
	}
}

func WithGenerateAccessors(accessorOpt Option[*Accessors]) Option[*Yoitsu] {
	return func(y *Yoitsu) {
		accessorOpt(&y.accessors)
	}
}

func WithMetadata(metaOpt Option[*Metadata]) Option[*Yoitsu] {
	return func(y *Yoitsu) {
		metaOpt(&y.metadata)
	}
}

func New(src Source, opts ...Option[*Yoitsu]) *Yoitsu {
	yt := &Yoitsu{
		src:       src,
		metadata:  Metadata{},
		accessors: Accessors{},
	}

	for _, opt := range opts {
		opt(yt)
	}

	if yt.metadata.packageName == "" {
		yt.metadata.packageName = "generated"
	}

	if yt.universe == nil {
		yt.universe = EmptyUniverse()
	}

	yt.parser = NewParser(yt)
	return yt
}

func (y *Yoitsu) getRootFromSrc() (interface{}, error) {
	b, err := y.src.Json()
	if err != nil {
		return nil, err
	}

	var root interface{}
	err = json.Unmarshal(b, &root)
	if err != nil {
		return nil, err
	}

	return root, nil
}

func (y *Yoitsu) GenerateFile() (err error) {
	y.root, err = y.getRootFromSrc()
	if err != nil {
		return
	}

	var (
		//gType       GeneratedType
		importSpecs []ast.Spec
		structDecls []ast.Decl

		//accessorImports []ast.Spec
		//accessorDecls   []ast.Decl
	)

	_, importSpecs, structDecls, err = y.generateJsonTypes()
	if err != nil {
		return
	}

	/*accessorDecls, accessorImports, err = y.generateMethodAccessors(gType)
	if err != nil {
		return
	}*/

	var decls []ast.Decl
	var allImportSpecs []ast.Spec

	if len(importSpecs) > 0 {
		allImportSpecs = append(allImportSpecs, importSpecs...)
	}

	/*if len(accessorImports) > 0 {
		allImportSpecs = append(allImportSpecs, accessorImports...)
	}*/

	if len(allImportSpecs) > 0 {
		decls = append(decls, &ast.GenDecl{
			Tok:   token.IMPORT,
			Specs: allImportSpecs,
		})
	}

	if len(structDecls) > 0 {
		decls = append(decls, structDecls...)
	}

	/*if len(accessorDecls) > 0 {
		decls = append(decls, accessorDecls...)
	}*/

	y.file = &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Text: fmt.Sprintf("// Generated by Yoitsu. DO NOT EDIT!"),
				},
			},
		},
		Name:  ast.NewIdent(y.metadata.packageName),
		Decls: decls,
	}

	return nil
}

func (y *Yoitsu) generateJsonTypes() (gType GeneratedType, importSpecs []ast.Spec, structDecls []ast.Decl, err error) {
	gType, err = y.parser.ParseRoot(y.src.Name(), y.root)
	if err != nil {
		return
	}

	structDecls = gType.Representation()
	importSpecs = y.imports(gType)
	return
}

func (y *Yoitsu) imports(gType GeneratedType) (imports []ast.Spec) {
	var addedImports []string

	for _, s := range gType.Imports() {
		if slices.Contains(addedImports, s) {
			continue
		}

		imports = append(imports, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: fmt.Sprintf("\"%s\"", s),
			},
		})

		addedImports = append(addedImports, s)
	}

	return
}

func (y *Yoitsu) WriteToDisk(dir string) error {
	if y.file == nil {
		return fmt.Errorf("no file generated. Call Yoitsu.GenerateFile first")
	}

	outFile, err := os.Create(filepath.Join(dir, y.src.Name()+".generated.go"))
	if err != nil {
		return err
	}
	defer outFile.Close()

	fset := token.NewFileSet()
	return format.Node(outFile, fset, y.file)
}
